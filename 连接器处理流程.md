连接器核心组件：

```
CoyoteAdapter：调度器，用于将Http11Processor传来的请求交付给合适的容器。在service方法中接收到来自于Http11Processor交付的可处理请求。同时也在service中设置HttpServletRequest和HttpServletResponse，根据URI设置处理此请求的容器执行路径（执行路径是指有engine-host-context-wrapper四个容器依次组成的执行路径）。如果能成功匹配上适合处理此请求的容器路径，就通过engine的执行阀的invoke进入到服务器的容器组件部分处理请求。最后处理完请求后调用request和response对应的完成方法，再根据传入到此方法的交付路径原路返回。

Http11Nio2Protocol：适用于Http/1.1的Nio2实现类

	ConnectionHandler：连接处理类。在process方法中接收到下层传来的请求，在此方法中复用/创建Http11Processor。然后再交付给Http11Processor实例（通过Http11Processor的process方法）。根据Http11Processor的process方法返回状态做不同处理。

	RecycledProcessors：处理器回收    

	Http11Processor：处理来自Http/1.1协议的请求处理器。在process方法中接收到来自ConnectionHandler转交的请求，在此方法中根据SocketEvent做进一步判断。如果可以正常处理此请求，就会调用自身的service方法。再service方法中才开始对请求包做准备。执行的操作包括但不限于解析请求行，解析部分请求头参数，添加合适的输入输出过滤器等。如果该请求能够进行处理，就交付给CoyoteAdapter。
	
	Nio2Channel：适用于Nio2的socket复用信道
		
	Nio2Endpoint：Nio2处理端点。一个此实例就会有一个Nio2的socket server实例。Nio2Acceptor接收到的请求后调用Nio2Endpoint的setSocketOptions方法，在此方法中创建Nio2SocketWrapper实例，复用/创建Nio2Channel信道，设置socket参数，然后再调用processSocket方法。在processSocket方法中复用/创建SocketProcessor实例，然后以和此请求接收同一线程的方式（Nio2固定的方式）交给SocketProcessor（通过run方法转到SocketProcessor实例）。
			
		SocketProcessor：socket处理器。在doRun方法中取得Nio2Endpoint实例传来的请求，在doRun方法中做一些简单处理后交付给ConnectionHandler实例的process方法。

  		Nio2SocketWrapper：Nio2Socket包装实例。有读和写两大类处理器的实现，联系着应用层面的缓冲区和socket信道缓冲区。以注册读写感兴趣的方式实现异步读写。可以从AsynchronousSocketChannel实例中取得两端主机和端口的信息。

  		Nio2Acceptor：Nio2方式的调度器，server socket在此方法中开始执行。客户端发起的请求会先到Nio2Acceptor实例中，然后Nio2Acceptor实例的completed方法（实现于CompletionHandler接口）与LimitLatch配合实现限流，如果请求不被限流，那么Acceptor选择继续同意请求（在serverSocket的accept方法中传入this，表示如果有请求过来，继续回调此处理器的completed方法）然后当前请求在completed方法中继续往下执行。调用Nio2Endpoint的setSocketOptions方法交付给Nio2Endpoint。在此方法中进行一部分参数设置后再往下调用processSocket方法

   
```



连接器处理流程（常规性请求处理）：

```
1、Nio2Acceptor：Nio2方式的调度器，server socket在此方法中开始执行。客户端发起的请求会先到Nio2Acceptor实例中，然后Nio2Acceptor实例的completed方法（实现于CompletionHandler接口）与LimitLatch配合实现限流，如果请求不被限流，那么Acceptor选择继续同意请求（在serverSocket的accept方法中传入this，表示如果有请求过来，继续回调此处理器的completed方法）然后当前请求在completed方法中继续往下执行。调用Nio2Endpoint的setSocketOptions方法交付给Nio2Endpoint。在此方法中进行一部分参数设置后再往下调用processSocket方法

2、Nio2Endpoint：Nio2处理端点。一个此实例就会有一个Nio2的socket server实例。Nio2Acceptor接收到的请求后调用Nio2Endpoint的setSocketOptions方法，在此方法中创建Nio2SocketWrapper实例，复用/创建Nio2Channel信道，设置socket参数，然后再调用processSocket方法。在processSocket方法中复用/创建SocketProcessor实例，然后以和此请求接收同一线程的方式（Nio2固定的方式）交给SocketProcessor（通过run方法转到SocketProcessor实例）。

3、SocketProcessor：socket处理器。在doRun方法中取得Nio2Endpoint实例传来的请求，在doRun方法中做一些简单处理后交付给ConnectionHandler实例的process方法。

4、ConnectionHandler：连接处理类。在process方法中接收到下层传来的请求，在此方法中复用/创建Http11Processor。然后再交付给Http11Processor实例（通过Http11Processor的process方法）。根据Http11Processor的process方法返回状态做不同处理。

5、Http11Processor：处理来自Http/1.1协议的请求处理器。在process方法中接收到来自ConnectionHandler转交的请求，在此方法中根据SocketEvent做进一步判断。如果可以正常处理此请求，就会调用自身的service方法。再service方法中才开始对请求包做准备。执行的操作包括但不限于解析请求行，解析部分请求头参数，添加合适的输入输出过滤器等。如果该请求能够进行处理，就交付给CoyoteAdapter。

6、CoyoteAdapter：调度器，用于将Http11Processor传来的请求交付给合适的容器。在service方法中接收到来自于Http11Processor交付的可处理请求。同时也在service中设置HttpServletRequest和HttpServletResponse，根据URI设置处理此请求的容器执行路径（执行路径是指有engine-host-context-wrapper四个容器依次组成的执行路径）。如果能成功匹配上适合处理此请求的容器路径，就通过engine的执行阀的invoke进入到服务器的容器组件部分处理请求。最后处理完请求后调用request和response对应的完成方法，再根据传入到此方法的交付路径原路返回。
```



简化版：

```
Nio2Acceptor.completed() -> Nio2Endpoint.setSocketOptions() -> Nio2Endpoint.processSocket() -> SocketProcessor.doRun() -> ConnectionHandler.process() -> Http11Processor.process() -> Http11Processor.process() -> Http11Processor.service() -> CoyoteAdapter.service()
```

